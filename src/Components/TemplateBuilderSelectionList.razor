@using Microsoft.FluentUI.AspNetCore.Components.Icons.Filled
@inject HttpClient Http
@inject TemplateRepository TemplateRepository

<FluentCard Style="border: 1px solid var(--neutral-stroke-divider);">

    <FluentToolbar>
        <FluentLabel Typo="Typography.Body" Weight="FontWeight.Bold">Selection regions</FluentLabel>
        <FluentBadge BackgroundColor="var(--neutral-fill-secondary)" Color="var(--neutral-foreground-rest)">
            @DocumentSelections.Count
        </FluentBadge>
    </FluentToolbar>

    @if (DocumentSelections.Count == 0)
    {
        <div style="text-align: center; padding: 32px 16px; color: var(--neutral-foreground-secondary);">
            <FluentIcon Value="@(new Icons.Regular.Size24.Document())" Style="margin-bottom: 8px;"/>
            <FluentLabel Typography="Typography.Caption" Style="display: block;">
                No document regions saved yet. Draw on the PDF to get started.
            </FluentLabel>
        </div>
    }
    else
    {
        <FluentStack Orientation="Orientation.Vertical" Style="padding: 10px; gap: 10px;">

            @* Document selections list *@
            <FluentDataGrid Items="@DocumentSelections.AsQueryable()"
                            RowSize="DataGridRowSize.Medium"
                            Style="width: 100%">
                <PropertyColumn Property="@(p => p.Name)" Sortable="true" Width="60%"/>
                <TemplateColumn Title="Actions" Align="@Align.End" Width="40%">
                    <FluentButton aria-label="Edit item" IconEnd="@(new Icons.Regular.Size16.Edit())"
                                  OnClick="@(() => HandleEditClicked(context))"/>
                    <FluentButton aria-label="Delete item" IconEnd="@(new Icons.Regular.Size16.Delete())"
                                  OnClick="@(() => HandleDeleteClicked(context))"/>
                </TemplateColumn>
            </FluentDataGrid>

            @* Extract data button *@
            <FluentButton Appearance="Appearance.Neutral"
                          @onclick="ExtractData"
                          disabled="@_isExtracting"
                          IconStart="@(new Icons.Regular.Size20.DocumentTextExtract())"
                          Loading="_isExtracting"
                          Style="width: 100%; margin-top: 20px;">
                @(_isExtracting ? "Extracting..." : "Extract data")
            </FluentButton>

        </FluentStack>
    }
</FluentCard>

@if (extractedData.Count > 0)
{
    <FluentCard Style="border: 1px solid var(--neutral-stroke-divider);">
        <FluentToolbar Style="padding: 0 10px; border-bottom: 1px solid var(--neutral-stroke-divider);">
            <FluentLabel Typography="Typography.Subtitle" Style="font-weight: 600;">
                Extracted data
            </FluentLabel>
            <FluentSpacer/>
        </FluentToolbar>

        <FluentStack Orientation="Orientation.Vertical"Style="padding: 10px; gap: 10px;">

            @* Extracted data list *@
            <FluentDataGrid Items="@extractedData.AsQueryable()">
                <PropertyColumn Property="@(p => p.Name)" Sortable="true"/>
                <PropertyColumn Property="@(p => p.Text)" Sortable="true"/>
            </FluentDataGrid>

        </FluentStack>
    </FluentCard>
}

@code {
    [Parameter] public List<DocumentSelection> DocumentSelections { get; set; } = new();
    [Parameter] public EventCallback<DocumentSelection> OnEdit { get; set; }
    [Parameter] public EventCallback<DocumentSelection> OnDelete { get; set; }
    [Parameter] public EventCallback OnExtract { get; set; }

    private List<ExtractedDocumentData> extractedData = new();
    private bool _isExtracting;

    private async Task HandleEditClicked(DocumentSelection selection) => await OnEdit.InvokeAsync(selection);

    private async Task HandleDeleteClicked(DocumentSelection selection) => await OnDelete.InvokeAsync(selection);

    private async Task ExtractData()
    {
        if (_isExtracting) return;

        _isExtracting = true;
        StateHasChanged();

        try
        {
            extractedData.Clear();

            using var httpResponse = await Http.GetAsync("sample-invoice.pdf");
            if (!httpResponse.IsSuccessStatusCode)
            {
                Console.WriteLine("Failed to load PDF");
                return;
            }

            using var stream = await httpResponse.Content.ReadAsStreamAsync();
            using var document = PdfDocument.Open(stream);

            if (document.NumberOfPages == 0) return;

            var page = document.GetPage(1); // Assuming we're working with page 1
            var words = page.GetWords().ToList();
            var blocks = DocstrumBoundingBoxes.Instance.GetBlocks(words);

            foreach (var selection in DocumentSelections)
            {
                var boundingBoxRect = new PdfRectangle(
                    bottomLeft: new PdfPoint(selection.PdfSelection.BottomLeftX, selection.PdfSelection.BottomLeftY),
                    topRight: new PdfPoint(selection.PdfSelection.TopRightX, selection.PdfSelection.TopRightY)
                );

                var blocksThatIntersect = blocks.Where(b => b.BoundingBox.IntersectsWith(boundingBoxRect)
                );

                var extractedText = string.Join("\n", blocksThatIntersect.Select(b => b.Text));

                extractedData.Add(new ExtractedDocumentData
                {
                    Name = selection.Name,
                    Text = extractedText
                });
            }

            await OnExtract.InvokeAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error extracting data: {ex.Message}");
        }
        finally
        {
            _isExtracting = false;
            StateHasChanged();
        }
    }

}
